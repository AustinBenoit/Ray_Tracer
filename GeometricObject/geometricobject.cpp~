#include "geometricobject.hpp"
#include "includes.hpp"

void GeometricObj::SetColour(rgb_t const& col)
{
  colour_ = col;
}

rgb_t GeometricObj::GetColour() const
{
  return colour_;
}


Sphere::Sphere(maths::Point3D center, float radius) :
    center_{ center },
    radius_sqr_{ radius * radius }
  { }

bool Sphere::Hit( maths::Ray const& ray, ShadeRec &trace_data) const
{
  maths::Vector o_c (ray.o.X() - center_.X(),
		     ray.o.Y() - center_.Y(),
		     ray.o.Z() - center_.Z());
	  
  auto a{ maths::Vector::Dot(ray.d, ray.d) };
  auto b{ maths::Vector::Dot(ray.d, o_c) * 2 };
  auto c{ maths::Vector::Dot(o_c, o_c) - radius_sqr_ };
  
  auto roots{ b * b - (4.0f * a * c) };
  
  if (roots >= 0.0f) {
    //hit
    float t = ((-b - std::sqrt(roots)) / (2.0f * a));
    if (t > 0.0f) {
      trace_data.hit_obj = true;
      trace_data.colour = colour_;
      return true;
    }
    
  }
  trace_data.hit_obj = false;
  return false;
}

bool Sphere::ShadowHit(maths::Ray const& ray, float& tmin) const
{
   maths::Vector o_c (ray.o.X() - center_.X(),
		     ray.o.Y() - center_.Y(),
		     ray.o.Z() - center_.Z());
	  
  auto a{ maths::Vector::Dot(ray.d, ray.d) };
  auto b{ maths::Vector::Dot(ray.d, o_c) * 2 };
  auto c{ maths::Vector::Dot(o_c, o_c) - radius_sqr_ };
  
  auto roots{ b * b - (4.0f * a * c) };
  if (roots >= 0.0f) {
    //hit
    float t = ((-b - std::sqrt(roots)) / (2.0f * a));
    if (t > 0.001f) {
      tmin = t;
      return true;
    }
    
  }

  return false;

}
